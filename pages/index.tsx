import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import { useEffect, useRef } from 'react'
import {
  ACESFilmicToneMapping,
  Clock,
  Group,
  Mesh,
  MeshBasicMaterial,
  PerspectiveCamera,
  PlaneGeometry,
  Scene,
  sRGBEncoding,
  WebGLRenderer
} from 'three'
import { getGLTFLoader, getTextureLoader } from '../cgi/loaders'
import styles from '../styles/Home.module.css'

const Home: NextPage = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  useEffect(() => {
    const isServer = typeof window === 'undefined';
    if (isServer || !canvasRef.current) {
      return;
    }


    const scene = new Scene();
    const textureLoader = getTextureLoader();
    const bakedTexture = textureLoader.load('baked.jpg');
    bakedTexture.flipY = false;
    bakedTexture.encoding = sRGBEncoding;

    const bakedMaterial = new MeshBasicMaterial({ map: bakedTexture });
    const portalMaterial = new MeshBasicMaterial({ color: 0x3967D5 });
    const lampMaterial = new MeshBasicMaterial({ color: 0xE7C182 });

    const gltfLoader = getGLTFLoader(true);
    gltfLoader.load('threejsjourney.glb', (gltf) => {
      gltf.scene.traverse(item => {
        const child = item as Mesh;
        if (!child.isMesh) {
          return;
        }

        child.material = bakedMaterial;

        if (child.name === 'portalFill') {
          child.material = portalMaterial;
        }

        if (child.name === 'lamp1' || child.name === 'lamp2') {
          child.material = lampMaterial;
        }

      });
      scene.add(gltf.scene);

      renderer.render(scene, camera);
    });
    const width = window.innerWidth;
    const height = window.innerHeight;
    const aspectRatio = width/height;


    const camera = new PerspectiveCamera(50, aspectRatio, 0.1, 100);
    camera.position.z = 13;
    camera.position.y = 10;
    camera.position.x = 15;
    camera.lookAt(0, 0, 0);
    const renderer = new WebGLRenderer({ canvas: canvasRef.current, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.outputEncoding = sRGBEncoding;
    renderer.toneMapping = ACESFilmicToneMapping;
    renderer.setSize(width, height);
    renderer.render(scene, camera);

    const tick = () =>
    {
        // Update controls
        // Render
        renderer.render(scene, camera)

        // Call tick again on the next frame
        window.requestAnimationFrame(tick)
    }

    tick()

  }, []);

  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <canvas id={styles.scene} ref={canvasRef}/>
    </div>
  )
}

export default Home
